# Introduction (i.e. domain characterization)

Visualization is fundamentally interdisciplinary, and, as such, visualization authors rarely possess or focus on a single skill set. Rather, practitioners frequently have interest, proficiency, or expertise in more than one discipline.

This work is particularly focused on authors that have expertise in both writing code and using graphic design software. This juxtaposition of skill sets is particularly interesting because it is possible to create a visual representation of data using either approach. The visualization research community has recently seen renewed interest in visualization toolkits that take advantage of both ways of working, however, significant challenges remain.

## What authors currently do (i.e. task abstraction)
A common approach to creating a visualization, especially when it needs to represent a large amount of data or include interactivity, is to write code. For example, common low-level tasks include:

- Creating SVG hierarchy structures using chains of d3 `enter().append()` statements
- Setting or adjusting the attributes of SVG structures using chains of `.attr()` statements, that often involve transformations of data attributes

While this works very well for simple visualizations with limited interactivity, there are some problems. The requirement to formally, _manually_ specify every graphics element and its properties places a practical limit on the richness of the graphics that they can create. Additionally, this approach to creating or adjusting graphics requires a lot of trial and error---and complex interactions can exacerbate the tedious nature of the process.

#### Practical limit on the richness of the graphics
With code, every element must be formally specified. This includes one-off elements like titles, labels, and annotations---which, for things like interactive storytelling, may be the predominant elements of a visualization. While things like CSS stylesheets or careful code abstractions can help, for the most part, the position, appearance, structure, and content of each of these elements must be created and adjusted manually.

#### Trial and error, compounded by interaction
Authors can't see what they are creating until they run the code. There are some mitigating strategies, such as page auto-refreshing---however, these approaches don't help much when the graphics that need to be manipulated are only visible after a series of interactions. Additional strategies, such as URL fragments, can auto-navigate through a series of interactions---but these can impose constraints on the overall visualization architecture, require additional time to set up and configure, and they can even incur debugging cycles of their own.

# What is possible
Rather than debugging graphics, we hypothesize that it is possible to **use the right tool for the right task**, i.e. use a drawing tool in conjunction with existing software development tools. We are not the first to pursue the elusive goal of drawing with data, and we do not claim to fully achieve it. Instead, we take novel steps that build toward that goal in the following ways:

- We bridge existing, industry-hardened software, with existing development practice
- We make it possible to use drawn graphics as input to machine learning techniques, for use in the authoring process

## Related work
(todo)

# Background (i.e. data abstraction: raw inputs)
- **SVG hierarchy**: generated by drawing software
- **Selection**: A set of elements within the SVG hierarchy, made by drawing software or d3 code
- **Linked datasets**: Separate files and/or API queries; for our purposes, we will assume these can be represented as JSON or XML hierarchies



High-level task abstraction
===========================



Specifically:

-

s that I code with a drawing program, while handling the associated logic with code... i.e. use the right tool for the right task

  - Examples:
    - High-level interface
    - Low-level `enter().append()` patterns
    - Low-level `.attr()` chains *that may be data-driven*

2. I want to take advantage of "data" created through the act of using drawing software, in the form of manually-encoded graphics attributes

Data abstraction
================



## Derived data

- **Augmented selection**: use D3\* to associate data items (could even be other graphics!) with the current selection
- **Enter Models**: Javascript functions that handle the classic `.append()` part of a D3 script. For now, these are learned\*\* _only_ from the selected SVG element tags (not based on SVG attributes or data\*). Enter models will not handle nesting on their own,\* though the user can certainly use them
- **Update Models**: Javascript functions that handle the classic `.attr()` chains in D3 scripts. These require an Enter Model as part of their input, but they _can_ be learned\*\* from associated data, in addition to the attributes of the SVG elements themselves. These can be applied to _any_ D3 selection or transition!

\* Potential for future work

\*\* For now\*, "learning" will be very simplistic (Low-level task abstraction)



Low-level task abstraction
==========================



- Enter Models: the common structure (e.g. `g ( rect, text ( tspan ))`) to all elements in the Augmented Selection is identified and replicated. Any nested variation (e.g. different numbers of `tspan` elements, or a nested visualization) will be excluded from the identified pattern. An error will result if there is no common pattern.

- For Update Models, the following approach will be taken:

  1. Each element in the selection, together with its associated data, will be serialized into a single vector. For example:

      ```xml
      <g id="sirHumphreyAppleby" transform="translate(220, 330)">
        <rect x="-10" y="-25" width="20" height="30"></rect>
        <text>Sir Humphrey Appleby</text>
      </g>
      ```

      bound to:

      ```json
      {
        "name": "Humphrey Appleby",
        "role": "Civil Servant",
        "honours": ["GCB", "CBE", "MVO", "MA (Oxon)"]
      }
      ```

      would become something like:

      | Header (not included)     | Linearized Vector     |
      |---------------------------|-----------------------|
      | g_id                      | sirHumphrey           |
      | g_transform_1_translate_x | 220                   |
      | g_transform_1_translate_y | 330                   |
      | g_rect_x                  | -10                   |
      | g_rect_y                  | -25                   |
      | g_rect_width              | 20                    |
      | g_rect_height             | 30                    |
      | g_text_content            | Sir Humphrey Applebee |
      | data_name                 | Sir Humphrey Applebee |
      | data_role                 | Civil Servant         |
      | data_honours_0            | GCB                   |
      | data_honours_1            | CBE                   |
      | data_honours_2            | MVO                   |
      | data_honours_3            | MA (Oxon)             |

  2. Compute an embedding for categorical values using word2vec (possibly via TensorFlow)

  3. Compute the SVD of the resulting matrix, from which we can extract:
    - Constant rules
    - Linear



- Given a set of "exemplar" graphics elements (including any nested elements underneath them):
  - Discover a* template that is common to each element, including:
    - common attribute values
    - common structures
    - (if the exemplars are bound to data) correlations between:
      - graphics attribute values and data attribute values
      - (less important, but potentially interesting): graphics structures and data structures
  \* _A_ template? _THE_ template? _A SET_ of templates?

- Given:
  - A template
  - A set of unbound data items
  instantiate the template for each data item

- Given:
  - A template
  - A set of data items bound to existing graphics
  perform an in-place (i.e. not touching elements that the template does not specify) update of the graphics

- Given a template:
  - Activate / deactivate certain rules in the template

Data Abstraction
================
SVG Graphics, arbitrary JSON files, and templates...

_What does a template look like?_

A template:
